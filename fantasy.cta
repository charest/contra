###############################################################################
# The spacing function
###############################################################################
function spacing(
  i : i64,
  n : i64 ) -> f64
  return f64(i) / f64(n)
end
  
###############################################################################
# The wave speed
###############################################################################
function wave_speed(
  gamma : f64,
  d : f64,
  p : f64,
  v : f64 ) -> f64

  var a : f64 = sqrt(gamma * p / d)
  var s : f64 = fabs(v) + a

  return s
end
  

###############################################################################
# The flux
###############################################################################
function compute_flux( 
  gamma : f64,
  dl : f64,
  pl : f64,
  vl : f64,
  el : f64,
  dr : f64,
  pr : f64,
  vr : f64,
  er : f64,
  flux : [f64] )

  var sl : f64 = wave_speed(gamma, dl, pl, vl) 
  var sr : f64 = wave_speed(gamma, dr, pr, vr)

  var smax : f64 = fmax(sl, sr)

  var moml : f64 = dl*vl
  var momr : f64 = dr*vr
  var enerl : f64 = dl*el
  var enerr : f64 = dr*er

  flux[0] = 0.5 * (moml + momr) - 0.5 * smax * (dr - dl)
  flux[1] = 0.5 * (moml*vl + pl + momr*vr + pr) - 0.5 * smax * (momr - moml)
  flux[2] = 0.5 * (moml*el + pl*vl + momr*er + pr*vr) - 0.5 * smax * (enerr - enerl)
  
end

###############################################################################
# This is the main function
###############################################################################
task main()

  # input parameters
  var num_parts = 2
  var num_cells : i64 = 1000000
  var num_ghost : i64 = 1
  var xleft : f64 = 0
  var xright : f64 = 1

  var cfl : f64 = 1.
  var max_its : i64 = 100
  var deltat : f64 = 1e-6

  var max_time : f64 = 0.2
  var gamma : f64 = 1.4
  
  #============================================================================
  # setup
  
  # setup main indexes
  var tot_cells : i64 = num_cells + num_ghost*2
  var tot_points : i64 = tot_cells + 1
 
  var parts = {0 .. num_parts-1}
  var cells = {0 .. tot_cells-1}
  var points = {0 .. tot_points-1}

  # size the cell index space
  var cell_sizes = [0; num_parts]
  var chunk = num_cells / num_parts
  var remain = num_cells % num_parts

  for i in 0 until num_parts do
    cell_sizes[i] = chunk
    if (remain > 0) then
      cell_sizes[i] = cell_sizes[i] + 1
      remain = remain - 1
    end
  end
  
  # add boundary ghosts to each side
  cell_sizes[0] = cell_sizes[0] + num_ghost
  cell_sizes[num_parts-1] = cell_sizes[num_parts-1] + num_ghost
  
  # size the points
  var point_sizes = [0; num_parts]
  var point_offsets = [0; num_parts+1]
  for i in 0 until num_parts do
    point_sizes[i] = cell_sizes[i] + 1
    point_offsets[i+1] = point_offsets[i] + cell_sizes[i]
  end

  # size the cells with extra ghosts
  var cell_sizes_with_ghost = [0; num_parts]
  cell_sizes_with_ghost[0] = cell_sizes[0] + num_ghost
  for i in 1 until num_parts-1 do
    cell_sizes_with_ghost[i] = cell_sizes[i] + 2*num_ghost
  end
  cell_sizes_with_ghost[num_parts-1] = cell_sizes[num_parts-1] + num_ghost
  
  # compute the expanded index size with ghosts
  var tot_cells_with_ghost = 0
  for i in 0 until num_parts do
    tot_cells_with_ghost = tot_cells_with_ghost + cell_sizes_with_ghost[i]
  end

  # determine the cell starting id for each rank
  var cnt = 0
  var cell_offsets = [0; num_parts+1]
  for i in 0 until num_parts do
    cnt = cnt + cell_sizes[i]
    cell_offsets[i+1] = cnt - num_ghost
  end
  
  #============================================================================
  # distributed fields
  
  var vertices : f64, over(points) = 0
  
  var centroids : f64, over(cells) = 0
  var deltax : f64, over(cells) = 0

  #============================================================================
  # geometry
  
  var length : f64 = xright - xleft
  var ileft = num_ghost
  var iright = tot_points - 1 - num_ghost
  
  #-------------------------------------
  # Points
  
  # compute the vertices
  foreach i in parts do
  
    # internal
    var jleft = 0
    var jright = length(points) - 1
    
    if (i==0) then
      jleft = jleft + num_ghost
    end
    if (i==num_parts-1) then
      jright = jright - num_ghost
    end

    for j in jleft to jright do
      var k = points[j]
      vertices[j] = xleft + spacing(k-ileft, num_cells) * length
    end

    # exterior
    if (i==0) then
      for j in 0 until num_ghost do
        vertices[jleft - num_ghost + j] = xleft - (vertices[jleft + num_ghost - j] - xleft)
      end
    end
    if (i==num_parts-1) then
      for j in 0 until num_ghost do
        vertices[jright + num_ghost - j] = xright + (xright - vertices[jright - num_ghost + j])
      end
    end

  end
    
  #-------------------------------------
  # Cells

  var cells_disjoint_part = partition cells by cell_sizes

  var points_part = partition points by point_sizes where
    foreach i in parts do
      for j in points do
        points[j] = point_offsets[i] + j
      end
    end
  end


  # now compute the cell centroids
  foreach i in parts do
    use cells_disjoint_part for cells
    partition centroids by cells_disjoint_part
    partition deltax    by cells_disjoint_part
    partition vertices  by points_part

    for j in cells do
      centroids[j] = (vertices[j] + vertices[j+1]) / 2
      deltax[j] = vertices[j+1] - vertices[j]
    end
  end
 
  #============================================================================
  # initalize the solution

  var density : f64, over(cells) = 0
  var velocity : f64, over(cells) = 0
  var pressure : f64, over(cells) = 0
  var energy : f64, over(cells) = 0
  
  foreach i in parts do
    use cells_disjoint_part for cells
    partition centroids by cells_disjoint_part
    partition density   by cells_disjoint_part
    partition pressure  by cells_disjoint_part
    partition velocity  by cells_disjoint_part
    partition energy    by cells_disjoint_part

    #-------------------------------------
    # Modelled domain

    for j in cells do
      if centroids[j] < 0.5 then
        density[j] = 1.
        pressure[j] = 1.
        velocity[j] = 0.
      else
        density[j] = 0.125
        pressure[j] = 0.1
        velocity[j] = 0.
      end
      energy[j] = pressure[j] / (density[j] *(gamma-1.)) + 0.5*velocity[j]*velocity[j]
    end

    #-------------------------------------
    # Physical ghosts exterior to domain

    # left
    if (i==0) then
      for j in 0 until num_ghost do
        var jghost = j
        var jinter = 2*num_ghost - j - 1
        density[jghost] = density[jinter]
        pressure[jghost] = pressure[jinter]
        velocity[jghost] = velocity[jinter]
        energy[jghost] = energy[jinter]
      end
    end
    # right
    if (i == num_parts-1) then
      var end_cells = length(cells) - 1
      for j in 0 until num_ghost do
        var jghost = end_cells + num_ghost - j - 1
        var jinter = end_cells - num_ghost + j
        density[jghost] = density[jinter]
        pressure[jghost] = pressure[jinter]
        velocity[jghost] = velocity[jinter]
        energy[jghost] = energy[jinter]
      end
    end

  end # parts

  #============================================================================
  # advance solution
      
  var dmassdt : f64, over(cells) = 0
  var dmomdt  : f64, over(cells) = 0
  var denerdt : f64, over(cells) = 0

  var cells_overlap_part = partition cells by cell_sizes_with_ghost where
    foreach i in parts do
      for j in cells do
        cells[j] = cell_offsets[i] + j
      end
    end
  end

  var time = 0.

  for n in 1 to max_its do
    
    
    #-----------------------------------
    # Compute time step
    
#    foreach i in parts do
#      partition cells by cell_sizes
#
#      var jleft = 0
#      var jright = length(cells) - 1
#  
#      if (i==0) then
#        jleft = jleft + num_ghost
#      elif (i==num_parts-1) then
#        jright = jright - num_ghost
#      end
#    
#      for j in ileft to iright do
#        var inv_dt : f64 = wave_speed(gamma, density[j], pressure[j], velocity[j]) / deltax[j]
#        deltat = fmax( inv_dt, deltat )
#      end
#    end
#
#    deltat = cfl / deltat
    deltat = fmin( max_time - time, deltat )

    #-----------------------------------
    # Compute residual
    foreach i in parts do
    
      use cells_disjoint_part for cells
    
      partition density  by cells_overlap_part
      partition pressure by cells_overlap_part
      partition velocity by cells_overlap_part
      partition energy   by cells_overlap_part
      
      partition dmassdt by cells_disjoint_part
      partition dmomdt  by cells_disjoint_part
      partition denerdt by cells_disjoint_part
 
      # zero residuals
      var local_cells = length(cells)
      for j in 0 until local_cells do
        dmassdt[j] = 0
        dmomdt [j] = 0
        denerdt[j] = 0
      end
      
      # determine left and right indices
      var jleft = 0
      var jright = local_cells
     
      if (i==0) then
        jleft = jleft + num_ghost
      end
      if (i==num_parts-1) then
        jright = jright - num_ghost
      end

      var offset = 0
      if (i!=0) then 
        offset = num_ghost
      end

      # compute rhs
      var flux : [f64] = [0; 3]

      for j in jleft to jright do

        var k = j + offset
      
        compute_flux(
          gamma,
          density[k-1],
          pressure[k-1],
          velocity[k-1],
          energy[k-1],
          density[k],
          pressure[k],
          velocity[k],
          energy[k],
          flux )

        if (j>jleft) then
          dmassdt[j-1] = dmassdt[j-1] + flux[0]
          dmomdt [j-1] = dmomdt [j-1] + flux[1]
          denerdt[j-1] = denerdt[j-1] + flux[2]
        end

        if (j<jright) then
          dmassdt[j] = dmassdt[j] - flux[0]
          dmomdt [j] = dmomdt [j] - flux[1]
          denerdt[j] = denerdt[j] - flux[2]
        end
  
      end # flux

    end # parts

    #-----------------------------------
    # Apply update
    foreach i in parts do
    
      use cells_disjoint_part for cells
    
      partition density  by cells_disjoint_part
      partition pressure by cells_disjoint_part
      partition velocity by cells_disjoint_part
      partition energy   by cells_disjoint_part
      
      partition dmassdt by cells_disjoint_part
      partition dmomdt  by cells_disjoint_part
      partition denerdt by cells_disjoint_part
   
      # adjust boundaries
      var jleft = 0
      var jright = length(cells) - 1
      
      if (i==0) then
        jleft = jleft + num_ghost
      end
      if (i==num_parts-1) then
         jright = jright - num_ghost
      end
       
      # apply the update
      for j in jleft to jright do       
        var factor = deltat / deltax[j]
        # density update
        var old_density = density[j]
        density[j] = density[j] - dmassdt[j] * factor
        var inv_density = 1. / density[j]
        # momentum
        velocity[j] = (old_density*velocity[j] - dmomdt[j] * factor) * inv_density
        # energy
        energy[j] = (old_density*energy[j] - denerdt[j] * factor) * inv_density
        # pressure
        pressure[j] = (energy[j] -  0.5*velocity[j]*velocity[j]) * density[j] * (gamma-1.)
      end
    
      # left boundary
      if (i==0) then
        for j in 0 until num_ghost do
          var jghost = j
          var jinter = 2*num_ghost - j - 1
          density[jghost] = density[jinter]
          pressure[jghost] = pressure[jinter]
          velocity[jghost] = velocity[jinter]
          energy[jghost] = energy[jinter]
        end
      end
      # right boundary
      if (i == num_parts-1) then
        var end_cells = length(cells) - 1
        for j in 0 until num_ghost do
          var jghost = end_cells + num_ghost - j - 1
          var jinter = end_cells - num_ghost + j
          density[jghost] = density[jinter]
          pressure[jghost] = pressure[jinter]
          velocity[jghost] = velocity[jinter]
          energy[jghost] = energy[jinter]
        end
      end

    end # parts

    time = time + deltat

    print("Step %5d, Time %e\n", n, time)

  end

  #============================================================================
  # output
  
  #var serialize = {0 .. 0}
  #foreach i in serialize do
 
  #  print("--BEGIN SOLUTION--\n")
  #  print("i x d v p e\n")
  #  for j in cells do
  #    print("%d %e %e %e %e %e\n", j, centroids[j], density[j], velocity[j], pressure[j], energy[j])
  #  end
  #  print("--END SOLUTION--\n")

  #end


end


###############################################################################
# launch main
###############################################################################
main()
