function wave_speed(
  #gamma : f64,
  d : f64,
  p : f64,
  v : f64 ) -> f64

  var gamma : f64 = 1.4
  var a : f64 = sqrt(gamma * p / d)
  var s : f64 = fabs(v) + a

  return s
end
  

function compute_flux( 
  gamma : f64,
  dl : f64,
  pl : f64,
  vl : f64,
  dr : f64,
  pr : f64,
  vr : f64,
  flux : [f64] )

  var el : f64 = pl / (dl *(gamma-1.)) + 0.5*vl*vl
  var sl : f64 = wave_speed(gamma, dl, pl, vl) 
  
  var er : f64 = pr / (dr *(gamma-1.)) + 0.5*vr*vr
  var sr : f64 = wave_speed(gamma, dr, pr, vr)

  var smax : f64 = fmax(sl, sr)

  var moml : f64 = dl*vl
  var momr : f64 = dr*vr
  var enerl : f64 = dl*el
  var enerr : f64 = dr*er

  flux[0] = 0.5 * (moml    + momr   ) - 0.5 * smax * (dr - dl)
  flux[1] = 0.5 * (moml*vl + pl + momr*vr + pr) - 0.5 * smax * (momr - moml)
  flux[2] = 0.5 * (moml*el + pl*vl + momr*er + pr*vr) - 0.5 * smax * (enerr - enerl)
  
end


###############################################################################
# This is the main function
###############################################################################
function main()

  # input parameters
  var num_cells : i64 = 10
  var num_ghost : i64 = 1
  var xleft : f64 = 0
  var xright : f64 = 1

  # compute the rest of the mesh
  var tot_cells : i64 = num_cells + num_ghost*2
  var ileft : i64 = num_ghost
  var iright : i64 = ileft + num_cells

  var tot_points : i64 = tot_cells + 1
  var length : f64 = xright - xleft

  # compute the vertices
  var vertices : [f64] = [0; tot_points]
  for i in ileft to iright do
    vertices[i] = xleft + f64(i-ileft) / f64(num_cells) * length
  end
  for i in 0 until num_ghost do
    vertices[ileft - num_ghost + i] = xleft - (vertices[ileft + num_ghost - i] - xleft)
    vertices[iright + num_ghost - i] = xright + (xright - vertices[iright - num_ghost + i])
  end

  # now compute the cell centroids
  var centroids : [f64] = [0; tot_cells]
  var deltax : [f64] = [0; tot_cells]
  for i in 0 until tot_cells do
    centroids[i] = (vertices[i] + vertices[i+1]) / 2
    deltax[i] = vertices[i+1] - vertices[i]
  end
 
  # initalize the solution
  var gamma : f64 = 1.4

  var density, velocity, pressure, energy : [f64] = [0; tot_cells]
  for i in ileft until iright do
    if centroids[i] < 0.5 then
      density[i] = 1.
      pressure[i] = 1.
      velocity[i] = 0.
    else
      density[i] = 0.125
      pressure[i] = 0.1
      velocity[i] = 0.
    end
  end
  
  for i in 0 until num_ghost do
    # left
    var jghost = ileft - num_ghost + i
    var jinter = ileft + num_ghost - i
    density[jghost] = density[jinter]
    pressure[jghost] = pressure[jinter]
    velocity[jghost] = velocity[jinter]
    # right
    jghost = iright + num_ghost - i
    jinter = iright - num_ghost + i
    density[jghost] = density[jinter]
    pressure[jghost] = pressure[jinter]
    velocity[jghost] = velocity[jinter]
  end

  # compute rhs
  var flux : [f64] = [0; 3]
  var dmassdt, dmomdt, denerdt : [f64] = [0; tot_cells]

  for i in ileft until iright do

    compute_flux( gamma, density[i-1], pressure[i-1], velocity[i-1],
      density[i], pressure[i], velocity[i], flux )
    
    dmassdt[i-1] = dmassdt[i-1] + flux[0]
    dmomdt [i-1] = dmomdt [i-1] + flux[1]
    denerdt[i-1] = denerdt[i-1] + flux[3]
    
    dmassdt[i] = dmassdt[i] - flux[0]
    dmomdt [i] = dmomdt [i] - flux[1]
    denerdt[i] = denerdt[i] - flux[3]
    
  end

  # compute time step
  var deltat : f64 = 0
  for i in ileft until iright do
    var inv_dt : f64 = wave_speed(gamma, density[i], pressure[i], velocity[i]) / deltax[i]
    deltat = fmax( inv_dt, deltat )
  end
  deltat = 1. / deltat
  print("%g\n", deltat)

  # apply the update
  for i in ileft until iright do
    density[i] = density[i] - dmassdt[i] * deltat / deltax[i]
  end

end


###############################################################################
# launch main
###############################################################################
main()
