###############################################################################
# The spacing function
###############################################################################
function spacing(
  i : i64,
  n : i64 ) -> f64
  return f64(i) / f64(n)
end
  
###############################################################################
# The wave speed
###############################################################################
function wave_speed(
  gamma : f64,
  d : f64,
  p : f64,
  v : f64 ) -> f64

  var a : f64 = sqrt(gamma * p / d)
  var s : f64 = fabs(v) + a

  return s
end
  

###############################################################################
# The flux
###############################################################################
function compute_flux( 
  gamma : f64,
  dl : f64,
  pl : f64,
  vl : f64,
  el : f64,
  dr : f64,
  pr : f64,
  vr : f64,
  er : f64,
  flux : [f64] )

  var sl : f64 = wave_speed(gamma, dl, pl, vl) 
  var sr : f64 = wave_speed(gamma, dr, pr, vr)

  var smax : f64 = fmax(sl, sr)

  var moml : f64 = dl*vl
  var momr : f64 = dr*vr
  var enerl : f64 = dl*el
  var enerr : f64 = dr*er

  flux[0] = 0.5 * (moml + momr) - 0.5 * smax * (dr - dl)
  flux[1] = 0.5 * (moml*vl + pl + momr*vr + pr) - 0.5 * smax * (momr - moml)
  flux[2] = 0.5 * (moml*el + pl*vl + momr*er + pr*vr) - 0.5 * smax * (enerr - enerl)
  
end

###############################################################################
# Ghost solution
###############################################################################
function update_ghost(
  density : [f64],
  velocity : [f64],
  pressure : [f64],
  energy : [f64],
  ileft : i64,
  iright : i64,
  num_ghost : i64 )

  for i in 0 until num_ghost do
    # left
    var jghost = ileft - num_ghost + i
    var jinter = ileft + num_ghost - i - 1
    density[jghost] = density[jinter]
    pressure[jghost] = pressure[jinter]
    velocity[jghost] = velocity[jinter]
    energy[jghost] = energy[jinter]
    # right
    jghost = iright + num_ghost - i - 1
    jinter = iright - num_ghost + i
    density[jghost] = density[jinter]
    pressure[jghost] = pressure[jinter]
    velocity[jghost] = velocity[jinter]
    energy[jghost] = energy[jinter]
  end

end

###############################################################################
# This is the main function
###############################################################################
task main()

  # input parameters
  var num_parts = 4
  var num_cells : i64 = 10
  var num_ghost : i64 = 1
  var xleft : f64 = 0
  var xright : f64 = 1

  var cfl : f64 = 1.
  var max_its : i64 = 1

  var max_time : f64 = 0.2
  var gamma : f64 = 1.4
  
  #============================================================================
  # setup
  
  # setup main indexes
  var tot_cells : i64 = num_cells + num_ghost*2
  var tot_points : i64 = tot_cells + 1
 
  var parts = {0 .. num_parts-1}
  var cells = {0 .. tot_cells-1}
  var points = {0 .. tot_points-1}

  # size the cell index space
  var cell_chunks = [0; num_parts]
  var chunk = num_cells / num_parts
  var remain = num_cells % num_parts

  for i in 0 until num_parts do
    cell_chunks[i] = chunk
    if (remain > 0) then
      cell_chunks[i] = cell_chunks[i] + 1
      remain = remain - 1
    end
  end

  # add boundary ghosts to each side
  cell_chunks[0] = cell_chunks[0] + num_ghost
  cell_chunks[num_parts-1] = cell_chunks[num_parts-1] + num_ghost
  
  # size the points
  var point_chunks = [0; num_parts]
  for i in 0 until num_parts do
    point_chunks[i] = cell_chunks[i] + 1
  end
  
  #============================================================================
  # distributed fields
  
  var vertices : f64, over(points) = 0
  
  var centroids : f64, over(cells) = 0
  var deltax : f64, over(cells) = 0

  #============================================================================
  # geometry
  
  var length : f64 = xright - xleft
  var ileft = num_ghost
  var iright = tot_points - 1 - num_ghost
  
  # compute the vertices
  for i in parts do
  
    # internal
    var jleft = 0
    var jright = length(points) - 1
    
    if (i==0) then
      jleft = jleft + num_ghost
    elif (i==num_parts-1) then
      jright = jright - num_ghost
    end

    for j in jleft to jright do
      var k = points[j]
      vertices[j] = xleft + spacing(k-ileft, num_cells) * length
    end

#    # exterior
#    if (i==0) then
#      for j in 0 until num_ghost do
#        vertices[jleft - num_ghost + j] = xleft - (vertices[jleft + num_ghost - j] - xleft)
#      end
#    elif (i==num_parts-1) then
#      for j in 0 until num_ghost do
#        vertices[jright + num_ghost - j] = xright + (xright - vertices[jright - num_ghost + j])
#      end
#    end

  end

## now compute the cell centroids
#    for i in 0 until tot_cells do
#      centroids[i] = (vertices[i] + vertices[i+1]) / 2
#      deltax[i] = vertices[i+1] - vertices[i]
#    end
#  end
 
#  #============================================================================
#  # initalize the solution
#
#  var density, velocity, pressure, energy : [f64] = [0; tot_cells]
#  for i in ileft until iright do
#    if centroids[i] < 0.5 then
#      density[i] = 1.
#      pressure[i] = 1.
#      velocity[i] = 0.
#    else
#      density[i] = 0.125
#      pressure[i] = 0.1
#      velocity[i] = 0.
#    end
#    energy[i] = pressure[i] / (density[i] *(gamma-1.)) + 0.5*velocity[i]*velocity[i]
#  end
#  
#  update_ghost(density, velocity, pressure, energy, ileft, iright, num_ghost)
#
#  #============================================================================
#  # advance solution
#
#  var time = 0.
#
#  for n in 1 to max_its do
#
#    # compute rhs
#    var flux : [f64] = [0; 3]
#    var dmassdt, dmomdt, denerdt : [f64] = [0; tot_cells]
#
#    for i in ileft to iright do
#
#      compute_flux(
#        gamma,
#        density[i-1],
#        pressure[i-1],
#        velocity[i-1],
#        energy[i-1],
#        density[i],
#        pressure[i],
#        velocity[i],
#        energy[i],
#        flux )
#
#      dmassdt[i-1] = dmassdt[i-1] + flux[0]
#      dmomdt [i-1] = dmomdt [i-1] + flux[1]
#      denerdt[i-1] = denerdt[i-1] + flux[2]
#      
#      dmassdt[i] = dmassdt[i] - flux[0]
#      dmomdt [i] = dmomdt [i] - flux[1]
#      denerdt[i] = denerdt[i] - flux[2]
#
#    end
#
#    # compute time step
#    var deltat : f64 = 0
#    for i in ileft until iright do
#      var inv_dt : f64 = wave_speed(gamma, density[i], pressure[i], velocity[i]) / deltax[i]
#      deltat = fmax( inv_dt, deltat )
#    end
#
#    deltat = cfl / deltat
#    deltat = fmin( max_time - time, deltat )
#
#    # apply the update
#    for i in ileft until iright do
#      var factor = deltat / deltax[i]
#      # density update
#      var old_density = density[i]
#      density[i] = density[i] - dmassdt[i] * factor
#      var inv_density = 1. / density[i]
#      # momentum
#      velocity[i] = (old_density*velocity[i] - dmomdt[i] * factor) * inv_density
#      # energy
#      energy[i] = (old_density*energy[i] - denerdt[i] * factor) * inv_density
#      # pressure
#      pressure[i] = (energy[i] -  0.5*velocity[i]*velocity[i]) * density[i] * (gamma-1.)
#    end
#    
#    update_ghost(density, velocity, pressure, energy, ileft, iright, num_ghost)
#
#    time = time + deltat
#
#    print("Step %5d, Time %e\n", n, time)
#
#  end
#
#  #============================================================================
#  # output
# 
#  print("--BEGIN SOLUTION--\n")
#  print("i x d v p e\n")
#  for i in 0 until tot_cells do
#    print("%d %e %e %e %e %e\n", i, centroids[i], density[i], velocity[i], pressure[i], energy[i])
#  end
#  print("--END SOLUTION--\n")


end


###############################################################################
# launch main
###############################################################################
main()
