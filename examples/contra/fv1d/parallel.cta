###############################################################################
# The spacing function
###############################################################################
function spacing(
  i : i64,
  n : i64 ) -> f64
  return f64(i) / f64(n)
end
  
###############################################################################
# The wave speed
###############################################################################
function wave_speed(
  gamma : f64,
  d : f64,
  p : f64,
  v : f64 ) -> f64

  var a : f64 = sqrt(gamma * p / d)
  var s : f64 = fabs(v) + a

  return s
end
  

###############################################################################
# The flux
###############################################################################
function compute_flux( 
  gamma : f64,
  dl : f64,
  pl : f64,
  vl : f64,
  el : f64,
  dr : f64,
  pr : f64,
  vr : f64,
  er : f64,
  flux : [f64] )

  var sl : f64 = wave_speed(gamma, dl, pl, vl) 
  var sr : f64 = wave_speed(gamma, dr, pr, vr)

  var smax : f64 = fmax(sl, sr)

  var moml : f64 = dl*vl
  var momr : f64 = dr*vr
  var enerl : f64 = dl*el
  var enerr : f64 = dr*er

  flux[0] = 0.5 * (moml + momr) - 0.5 * smax * (dr - dl)
  flux[1] = 0.5 * (moml*vl + pl + momr*vr + pr) - 0.5 * smax * (momr - moml)
  flux[2] = 0.5 * (moml*el + pl*vl + momr*er + pr*vr) - 0.5 * smax * (enerr - enerl)
  
end

###############################################################################
# Ghost solution
###############################################################################
function update_ghost(
  density : [f64],
  velocity : [f64],
  pressure : [f64],
  energy : [f64],
  ileft : i64,
  iright : i64,
  num_ghost : i64 )

  for i in 0 until num_ghost do
    # left
    var jghost = ileft - num_ghost + i
    var jinter = ileft + num_ghost - i - 1
    density[jghost] = density[jinter]
    pressure[jghost] = pressure[jinter]
    velocity[jghost] = velocity[jinter]
    energy[jghost] = energy[jinter]
    # right
    jghost = iright + num_ghost - i - 1
    jinter = iright - num_ghost + i
    density[jghost] = density[jinter]
    pressure[jghost] = pressure[jinter]
    velocity[jghost] = velocity[jinter]
    energy[jghost] = energy[jinter]
  end

end

###############################################################################
# This is the main function
###############################################################################
task main()

  # input parameters
  var num_parts = 2
  var num_cells : i64 = 3
  var num_ghost : i64 = 1
  var xleft : f64 = 0
  var xright : f64 = 1

  var cfl : f64 = 1.
  var max_its : i64 = 1

  var max_time : f64 = 0.2
  var gamma : f64 = 1.4
  
  #============================================================================
  # setup
  
  # setup main indexes
  var tot_cells : i64 = num_cells + num_ghost*2
  var tot_points : i64 = tot_cells + 1
 
  var parts = {0 .. num_parts-1}
  var cells = {0 .. tot_cells-1}
  var points = {0 .. tot_points-1}

  # size the cell index space
  var cell_sizes = [0; num_parts]
  var chunk = num_cells / num_parts
  var remain = num_cells % num_parts

  for i in 0 until num_parts do
    cell_sizes[i] = chunk
    if (remain > 0) then
      cell_sizes[i] = cell_sizes[i] + 1
      remain = remain - 1
    end
  end
  
  # add boundary ghosts to each side
  cell_sizes[0] = cell_sizes[0] + num_ghost
  cell_sizes[num_parts-1] = cell_sizes[num_parts-1] + num_ghost
  
  # size the points
  var point_sizes = [0; num_parts]
  var point_offsets = [0; num_parts+1]
  for i in 0 until num_parts do
    point_sizes[i] = cell_sizes[i] + 1
    point_offsets[i+1] = point_offsets[i] + cell_sizes[i]
  end

  # size the cells with extra ghosts
  var cell_sizes_with_ghost = [0; num_parts]
  cell_sizes_with_ghost[0] = cell_sizes[0] + num_ghost
  for i in 1 until num_parts-1 do
    cell_sizes_with_ghost[i] = cell_sizes[i] + 2*num_ghost
  end
  cell_sizes_with_ghost[num_parts-1] = cell_sizes[num_parts-1] + num_ghost
  
  # compute the expanded index size with ghosts
  var tot_cells_with_ghost = 0
  for i in 0 until num_parts do
    tot_cells_with_ghost = tot_cells_with_ghost + cell_sizes_with_ghost[i]
  end

  # determine the cell starting id for each rank
  var cnt = 0
  var cell_offsets = [0; num_parts+1]
  for i in 0 until num_parts do
    cnt = cnt + cell_sizes[i]
    cell_offsets[i+1] = cnt - num_ghost
  end
  
  #============================================================================
  # distributed fields
  
  var vertices : f64, over(points) = 0
  
  var centroids : f64, over(cells) = 0
  var deltax : f64, over(cells) = 0

  #============================================================================
  # geometry
  
  var length : f64 = xright - xleft
  var ileft = num_ghost
  var iright = tot_points - 1 - num_ghost
  
  #-------------------------------------
  # Points
  
  # compute the vertices
  foreach i in parts do
  
    # internal
    var jleft = 0
    var jright = length(points) - 1
    
    if (i==0) then
      jleft = jleft + num_ghost
    elif (i==num_parts-1) then
      jright = jright - num_ghost
    end

    for j in jleft to jright do
      var k = points[j]
      vertices[j] = xleft + spacing(k-ileft, num_cells) * length
    end

    # exterior
    if (i==0) then
      for j in 0 until num_ghost do
        vertices[jleft - num_ghost + j] = xleft - (vertices[jleft + num_ghost - j] - xleft)
      end
    elif (i==num_parts-1) then
      for j in 0 until num_ghost do
        vertices[jright + num_ghost - j] = xright + (xright - vertices[jright - num_ghost + j])
      end
    end

  end
    
  #-------------------------------------
  # Cells

  # now compute the cell centroids
  foreach i in parts do
    partition cells by cell_sizes

    partition points by point_sizes where
      for j in points do
        points[j] = point_offsets[i] + j
      end
    end

    for j in cells do
      centroids[j] = (vertices[j] + vertices[j+1]) / 2
      deltax[j] = vertices[j+1] - vertices[j]
    end
  end
 
  #============================================================================
  # initalize the solution

  var density : f64, over(cells) = 0
  var velocity : f64, over(cells) = 0
  var pressure : f64, over(cells) = 0
  var energy : f64, over(cells) = 0
  
  #-------------------------------------
  # Modelled domain

  foreach i in parts do
    partition cells by cell_sizes

    for j in cells do
      if centroids[i] < 0.5 then
        density[i] = 1.
        pressure[i] = 1.
        velocity[i] = 0.
      else
        density[i] = 0.125
        pressure[i] = 0.1
        velocity[i] = 0.
      end
      energy[i] = pressure[i] / (density[i] *(gamma-1.)) + 0.5*velocity[i]*velocity[i]
    end
  end
  
  #-------------------------------------
  # Physical ghosts exterior to domain

  foreach i in parts do
    partition cells by cell_sizes

    # left
    if (i==0) then
      for j in 0 until num_ghost do
        var jghost = j
        var jinter = 2*num_ghost - j - 1
        density[jghost] = density[jinter]
        pressure[jghost] = pressure[jinter]
        velocity[jghost] = velocity[jinter]
        energy[jghost] = energy[jinter]
      end
    # right
    elif (i == num_parts-1) then
      var end_cells = length(cells) - 1
      for j in 0 until num_ghost do
        var jghost = end_cells + num_ghost - j - 1
        var jinter = end_cells - num_ghost + j
        density[jghost] = density[jinter]
        pressure[jghost] = pressure[jinter]
        velocity[jghost] = velocity[jinter]
        energy[jghost] = energy[jinter]
      end
    end

  end

  #============================================================================
  # advance solution
      
  var cells_disjoint = {0 .. tot_cells-1}
  var dmassdt : f64, over(cells_disjoint) = 0
  var dmomdt  : f64, over(cells_disjoint) = 0
  var denerdt : f64, over(cells_disjoint) = 0

  var time = 0.

  for n in 1 to max_its do
    
    
    #-----------------------------------
    # Compute time step
    
    var deltat : f64 = 1e-3
#    foreach i in parts do
#      partition cells by cell_sizes
#
#      var jleft = 0
#      var jright = length(cells) - 1
#  
#      if (i==0) then
#        jleft = jleft + num_ghost
#      elif (i==num_parts-1) then
#        jright = jright - num_ghost
#      end
#    
#      for j in ileft to iright do
#        var inv_dt : f64 = wave_speed(gamma, density[i], pressure[i], velocity[i]) / deltax[i]
#        deltat = fmax( inv_dt, deltat )
#      end
#    end
#
#    deltat = cfl / deltat
#    deltat = fmin( max_time - time, deltat )

    #-----------------------------------
    # Compute residual
    foreach i in parts do
    
      partition cells_disjoint by cell_sizes

      partition cells by cell_sizes_with_ghost where
        for j in cells do
          cells[j] = cell_offsets[i] + j
        end
      end
  
      var local_cells = length(cells)
      
      # determine left and right indices
      var jleft = 0
      var jright = length(cells_disjoint) - 1
     
      if (i==0) then
        jleft = jleft + num_ghost
      elif (i==num_parts-1) then
        jright = jright - num_ghost
      end

      var offset = 0
      if (i!=0) offset = num_ghost

      # compute rhs
      var flux : [f64] = [0; 3]

      for j in jleft to jright do
  
        compute_flux(
          gamma,
          density[j-1],
          pressure[j-1],
          velocity[j-1],
          energy[j-1],
          density[j],
          pressure[j],
          velocity[j],
          energy[j],
          flux )

        if (j!=0) then
          dmassdt[j] = dmassdt[j-1] + flux[0]
          dmomdt [j] = dmomdt [j-1] + flux[1]
          denerdt[j] = denerdt[j-1] + flux[2]
        end
        
        dmassdt[j] = dmassdt[j] - flux[0]
        dmomdt [j] = dmomdt [j] - flux[1]
        denerdt[j] = denerdt[j] - flux[2]

        k = k+1
  
      end # flux

    end # parts

    #-----------------------------------
    # Apply update
    foreach i in parts do
    
      partition cells_disjoint by cell_sizes
      partition cells by cell_sizes
   
      # adjust boundaries
      var jleft = 0
      var jright = length(cells) - 1
      
      if (i==0) then
        jleft = jleft + num_ghost
      elif (i==num_parts-1) then
         jright = jright - num_ghost
      end
 
      # apply the update
      for j in jleft to jright do 
        var factor = deltat / deltax[j]
        # density update
        var old_density = density[j]
        density[j] = density[j] - dmassdt[j] * factor
        var inv_density = 1. / density[j]
        # momentum
        velocity[j] = (old_density*velocity[j] - dmomdt[j] * factor) * inv_density
        # energy
        energy[j] = (old_density*energy[j] - denerdt[j] * factor) * inv_density
        # pressure
        pressure[j] = (energy[j] -  0.5*velocity[j]*velocity[j]) * density[j] * (gamma-1.)
      end
    
      # left boundary
      if (i==0) then
        for j in 0 until num_ghost do
          var jghost = j
          var jinter = 2*num_ghost - j - 1
          density[jghost] = density[jinter]
          pressure[jghost] = pressure[jinter]
          velocity[jghost] = velocity[jinter]
          energy[jghost] = energy[jinter]
        end
      # right boundary
      elif (i == num_parts-1) then
        var end_cells = length(cells) - 1
        for j in 0 until num_ghost do
          var jghost = end_cells + num_ghost - j - 1
          var jinter = end_cells - num_ghost + j
          density[jghost] = density[jinter]
          pressure[jghost] = pressure[jinter]
          velocity[jghost] = velocity[jinter]
          energy[jghost] = energy[jinter]
        end
      end

    end # parts

    time = time + deltat

    print("Step %5d, Time %e\n", n, time)

  end

#  #============================================================================
#  # output
# 
#  print("--BEGIN SOLUTION--\n")
#  print("i x d v p e\n")
#  for i in 0 until tot_cells do
#    print("%d %e %e %e %e %e\n", i, centroids[i], density[i], velocity[i], pressure[i], energy[i])
#  end
#  print("--END SOLUTION--\n")


end


###############################################################################
# launch main
###############################################################################
main()
